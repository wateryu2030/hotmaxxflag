# 比价具体实现方案

## 一、整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          货盘价格对比分析 4 阶段闭环                           │
└─────────────────────────────────────────────────────────────────────────────┘

  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
  │  阶段1       │    │  阶段2       │    │  阶段3       │    │  阶段4       │
  │  数据标准化   │───▶│  竞品检索    │───▶│  指标量化    │───▶│  货盘分层    │
  └──────────────┘    └──────────────┘    └──────────────┘    └──────────────┘
        │                     │                    │                    │
        ▼                     ▼                    ▼                    ▼
  t_htma_sale          Fetcher 接口          价格优势率            5 类策略
  t_htma_stock         多数据源适配          独家款标注            可执行动作
```

---

## 二、阶段 1：自有数据标准化

### 2.1 数据来源

| 表 | 字段 | 用途 |
|----|------|------|
| t_htma_sale | sku_code, product_name, category, sale_qty, sale_amount, gross_profit | 商品名、销量、售价、毛利 |
| t_htma_stock | product_name | 补全品名（sale 可能为空） |

### 2.2 标准化逻辑（`_clean_product_name`）

```python
# 1. 过滤无关词
_FILTER_WORDS = ("特价", "促销", "包邮", "限时", "秒杀", "清仓", "亏本", "爆款", "热卖")

# 2. 单位统一（便于同款匹配）
"克"→"g", "千克"→"kg", "毫升"→"ml", "升"→"L"

# 3. 去特殊符号
移除 【】[]()（）*#@，多余空格合并
```

### 2.3 筛选条件

- 销售额 > 100 元、销量 ≥ 1
- 排除：购物袋、包装袋、塑料袋
- 单价 0 < unit_price ≤ 10000
- 标准化后名称长度 ≥ 2

### 2.4 输出结构

```python
{
    "sku_code": str,
    "raw_name": str,      # 原始品名
    "std_name": str,      # 标准化后（用于检索）
    "category": str,
    "category_large": str,
    "sale_qty": float,
    "sale_amount": float,
    "gross_profit": float,
    "unit_price": float   # 好特卖单价
}
```

---

## 三、阶段 2：竞品价格检索

### 3.1 Fetcher 接口契约

```python
def fetcher(std_name: str, barcode: str | None = None) -> dict | None:
    """
    输入：标准化商品名 std_name，可选条码 barcode
    输出：{"min_price": float, "platform": str, "is_same_spec": bool}
         或 None（无竞品/检索失败）
    """
```

### 3.2 数据源实现

| 数据源 | 输入 | 请求方式 | 返回解析 |
|--------|------|----------|----------|
| **聚合数据** | 关键词 q | GET `apis.juhe.cn/shopping/query?key=&q=` | 从 result.list 取各条 price，min() 为最低价 |
| **极速数据（百度 API 商城）** | 条码 或 关键词 | GET `api.jisuapi.com/barcode2/query` 或 `shopping/search` | result.price / marketprice |
| **OneBound（淘宝/京东聚合）** | 关键词 q | GET `api-gw.onebound.cn/.../item_search_bijia/?key=&q=` | 按文档解析 price 列表 |
| **Mock** | 任意 | 无 | 基于名称生成模拟价，用于调试 |

### 3.3 检索策略

1. **有条码**：优先条码查询（同款匹配更准）
2. **无条码**：用 std_name 关键词搜索
3. **多数据源**：按优先级依次尝试，任一成功即返回
4. **异常处理**：单次超时 8s，失败返回 None（记为独家款）

### 3.4 配置

```bash
# .env
JUHE_PRICE_KEY=xxx          # 聚合数据
JUHE_PRICE_URL=xxx          # 可选，覆盖默认地址
BAIDU_APISTORE_KEY=xxx      # 百度 API 商城
```

---

## 四、阶段 3：价格对比与指标量化

### 4.1 核心公式

```
价格优势率 = (竞品最低价 - 好特卖售价) / 竞品最低价 × 100%
```

- **正数**：好特卖更便宜，数值越大优势越强
- **负数**：好特卖更贵，价格劣势
- **空值**：无竞品数据，记为独家款

### 4.2 分层阈值

| 分层 | 价格优势率 | 策略 |
|------|------------|------|
| 高优势款 | ≥ 20% | 重点主推 |
| 中等优势款 | 5% ~ 20% | 维持现状 |
| 无优势款 | 0% ~ 5% | 微调定价/组合销售 |
| 价格劣势款 | < 0% | 清库存/替换供应商 |
| 独家款 | 无竞品 | 提升毛利/差异化主推 |

### 4.3 输出字段（每 SKU）

```python
{
    ...stage1_fields,
    "advantage_pct": float | None,   # 价格优势率
    "competitor_min": float | None,  # 竞品最低价
    "platform": str | None,          # 数据来源
    "tier": str                     # 分层标签
}
```

---

## 五、阶段 4：货盘分层与决策输出

### 5.1 分层汇总

按 `tier` 分组，统计各层数量，提取 Top 商品名用于策略描述。

### 5.2 策略输出模板

```
【高优势款】N 个，价格优势≥20%，重点主推：A、B、C...
【中等优势款】N 个，优势5%~20%，维持现状
【无优势款】N 个，优势0~5%，可微调定价或组合销售
【价格劣势款】N 个，建议清库存/替换供应商：A、B、C...
【独家款】N 个，无竞品，可提升毛利或差异化主推
```

### 5.3 可执行动作

- 高优势款 → 堆头/端架、小红书种草、移动点位旁陈列
- 价格劣势款 → 核查进价、限期清仓、替换供应商
- 独家款 → 差异化主推、提升毛利空间

---

## 六、调用链路

### 6.1 入口

| 入口 | 说明 |
|------|------|
| `npm run htma:price_compare` | 命令行/OpenCLAW 脚本 |
| `GET /api/price_compare?days=30` | HTTP API |
| AI 对话「性价比」「比价」 | 自动触发 4 阶段分析 |

### 6.2 执行流程

```python
# run_full_pipeline(conn, store_id, days, use_mock_fetcher, fetcher)
items = stage1_standardize(conn, store_id, days)      # 1. 标准化
items = stage3_calc_advantage(items, fetcher, use_mock) # 2+3. 检索+量化
portfolio = stage4_portfolio_analysis(items)            # 4. 分层
return {"items": items, "portfolio": portfolio, ...}
```

### 6.3 Fetcher 选择顺序

1. 传入的 `fetcher` 参数
2. `get_configured_fetcher()`（环境变量配置）
3. `stage2_mock_fetcher`（`use_mock_fetcher=True` 时）

---

## 七、可选增强

### 7.1 结果缓存

- 表：`t_htma_price_compare`（已建）
- 策略：按 `run_at` 缓存，24 小时内复用，减少 API 调用

### 7.2 限流与重试

- 聚合数据/第三方 API 通常有 QPS 限制
- 建议：每请求间隔 100–200ms，失败重试 1 次

### 7.3 条码补全

- 若 `t_htma_stock` 有 `barcode` 字段，可传入 fetcher 提高同款匹配率
- 需在 stage1 的 SQL 中 SELECT barcode

### 7.4 多平台最低价

- 当前取「所有结果中的最低价」
- 可扩展为按平台分组，输出「京东最低」「淘宝最低」等

---

## 八、文件与职责

| 文件 | 职责 |
|------|------|
| `htma_dashboard/price_compare.py` | 4 阶段主逻辑、报告格式化 |
| `htma_dashboard/baidu_fetcher.py` | 聚合数据、百度 API 商城 fetcher |
| `scripts/openclaw_price_compare.sh` | 命令行执行入口 |
| `scripts/07_create_price_compare.sql` | 结果表（可选缓存） |
| `.env.example` | 环境变量示例 |

---

## 九、数据源申请链接

| 数据源 | 申请链接 |
|--------|----------|
| 聚合数据 商品比价 | https://www.juhe.cn/docs/api/id/137 |
| 百度 API 商城 | https://apis.baidu.com/ |
| OneBound 比价（淘宝/京东） | 需自行搜索「onebound 比价」获取 |
